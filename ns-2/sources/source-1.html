


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > AccountsServiceImpl</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">com.example.accountsservices.service.impl</a>
</div>

<h1>Coverage Summary for Class: AccountsServiceImpl (com.example.accountsservices.service.impl)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">AccountsServiceImpl</td>
<td class="coverageStat">
  <span class="percent">
    92.6%
  </span>
  <span class="absValue">
    (25/27)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    90.4%
  </span>
  <span class="absValue">
    (331/366)
  </span>
</td>
</tr>
  <tr>
    <td class="name">AccountsServiceImpl$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AccountsServiceImpl$ValidateType</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    93.3%
  </span>
  <span class="absValue">
    (28/30)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    90.6%
  </span>
  <span class="absValue">
    (339/374)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package com.example.accountsservices.service.impl;
&nbsp;
&nbsp;import com.example.accountsservices.dto.*;
&nbsp;import com.example.accountsservices.dto.inputDtos.DeleteInputRequestDto;
&nbsp;import com.example.accountsservices.dto.inputDtos.GetInputRequestDto.DIRECTION;
&nbsp;import com.example.accountsservices.dto.inputDtos.GetInputRequestDto;
&nbsp;import com.example.accountsservices.dto.inputDtos.PostInputRequestDto;
&nbsp;import com.example.accountsservices.dto.inputDtos.PutInputRequestDto;
&nbsp;import com.example.accountsservices.dto.outputDtos.OutputDto;
&nbsp;import com.example.accountsservices.exception.AccountsException;
&nbsp;import com.example.accountsservices.exception.BadApiRequestException;
&nbsp;import com.example.accountsservices.exception.CustomerException;
&nbsp;import com.example.accountsservices.model.Accounts;
&nbsp;import com.example.accountsservices.model.Customer;
&nbsp;import com.example.accountsservices.repository.AccountsRepository;
&nbsp;import com.example.accountsservices.repository.CustomerRepository;
&nbsp;import com.example.accountsservices.service.AbstractAccountsService;
&nbsp;import com.example.accountsservices.service.IFileService;
&nbsp;import org.springframework.beans.factory.annotation.Autowired;
&nbsp;import org.springframework.beans.factory.annotation.Qualifier;
&nbsp;import org.springframework.beans.factory.annotation.Value;
&nbsp;import org.springframework.data.domain.Page;
&nbsp;import org.springframework.data.domain.PageRequest;
&nbsp;import org.springframework.data.domain.Pageable;
&nbsp;import org.springframework.data.domain.Sort;
&nbsp;import org.springframework.security.crypto.password.PasswordEncoder;
&nbsp;import org.springframework.stereotype.Component;
&nbsp;import org.springframework.stereotype.Service;
&nbsp;
&nbsp;
&nbsp;import java.io.IOException;
&nbsp;import java.time.LocalDate;
&nbsp;import java.time.Period;
&nbsp;import java.util.*;
&nbsp;import java.util.List;
&nbsp;
&nbsp;import static com.example.accountsservices.helpers.CodeRetrieverHelper.getBranchCode;
&nbsp;import static com.example.accountsservices.helpers.MapperHelper.*;
&nbsp;import static com.example.accountsservices.helpers.PagingHelper.*;
&nbsp;import static com.example.accountsservices.model.Accounts.AccountStatus;
&nbsp;
&nbsp;
&nbsp;/**
&nbsp; * @parent AccountsService
&nbsp; * @class AccountsServiceImpl
&nbsp; * @fields accountsRepository
&nbsp; * @fieldTypes AccountsRepository
&nbsp; * @overridenMethods createAccounts, getAccountByCustomerId,
&nbsp; * updateAccountByCustomerIdAndAccountNumber,updateBeneficiaryDetails
&nbsp; * @specializedMethods None
&nbsp; */
&nbsp;
&nbsp;@Service(&quot;accountsServicePrimary&quot;)
&nbsp;public class AccountsServiceImpl extends AbstractAccountsService {
&nbsp;    private final AccountsRepository accountsRepository;
&nbsp;
&nbsp;    private final CustomerRepository customerRepository;
&nbsp;
&nbsp;    private final IFileService fIleService;
&nbsp;
&nbsp;    @Autowired
&nbsp;    private PasswordEncoder passwordEncoder;
<b class="fc">&nbsp;    private final AccountStatus STATUS_BLOCKED = AccountStatus.BLOCKED;</b>
<b class="fc">&nbsp;    private final AccountStatus STATUS_OPEN = AccountStatus.OPEN;</b>
<b class="fc">&nbsp;    private final AccountStatus STATUS_CLOSED = AccountStatus.CLOSED;</b>
&nbsp;    public static final String REQUEST_TO_BLOCK = &quot;BLOCK&quot;;
<b class="fc">&nbsp;    private final String INIT = &quot;INIT&quot;;</b>
<b class="fc">&nbsp;    private final String UPDATE = &quot;UPDATE&quot;;</b>
&nbsp;
&nbsp;    @Value(&quot;${customer.profile.images.path}&quot;)
&nbsp;    private  String IMAGE_PATH;
&nbsp;
<b class="fc">&nbsp;    private enum ValidateType {</b>
<b class="fc">&nbsp;        UPDATE_CASH_LIMIT, UPDATE_HOME_BRANCH,</b>
<b class="fc">&nbsp;        GENERATE_CREDIT_SCORE, UPDATE_CREDIT_SCORE,</b>
<b class="fc">&nbsp;        UPLOAD_PROFILE_IMAGE, CLOSE_ACCOUNT, RE_OPEN_ACCOUNT,</b>
<b class="fc">&nbsp;        BLOCK_ACCOUNT, CREATE_ACC, ADD_ACC</b>
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    private final ValidateType UPDATE_CASH_LIMIT = ValidateType.UPDATE_CASH_LIMIT;</b>
<b class="fc">&nbsp;    private final ValidateType UPDATE_HOME_BRANCH = ValidateType.UPDATE_HOME_BRANCH;</b>
<b class="fc">&nbsp;    private final ValidateType CLOSE_ACCOUNT = ValidateType.CLOSE_ACCOUNT;</b>
<b class="fc">&nbsp;    private final ValidateType RE_OPEN_ACCOUNT = ValidateType.RE_OPEN_ACCOUNT;</b>
<b class="fc">&nbsp;    private final ValidateType BLOCK_ACCOUNT = ValidateType.BLOCK_ACCOUNT;</b>
<b class="fc">&nbsp;    private final ValidateType CREATE_ACCOUNT = ValidateType.CREATE_ACC;</b>
<b class="fc">&nbsp;    private final ValidateType ADD_ACCOUNT = ValidateType.ADD_ACC;</b>
<b class="fc">&nbsp;    private final ValidateType UPLOAD_PROFILE_IMAGE = ValidateType.UPLOAD_PROFILE_IMAGE;</b>
&nbsp;
&nbsp;
&nbsp;    /**
&nbsp;     * @paramType AccountsRepository
&nbsp;     * @returnType NA
&nbsp;     */
&nbsp;    public AccountsServiceImpl(AccountsRepository accountsRepository, CustomerRepository customerRepository,
&nbsp;                               @Qualifier(&quot;fileServicePrimary&quot;) IFileService fIleService) {
<b class="fc">&nbsp;        super(accountsRepository, customerRepository);</b>
<b class="fc">&nbsp;        this.accountsRepository = accountsRepository;</b>
<b class="fc">&nbsp;        this.customerRepository = customerRepository;</b>
<b class="fc">&nbsp;        this.fIleService = fIleService;</b>
&nbsp;    }
&nbsp;
&nbsp;    private Boolean checkConflictingAccountUpdateConditionForBranch(Accounts accounts, AccountsDto accountsDto, String locality) throws AccountsException {
<b class="fc">&nbsp;        String location = String.format(&quot;Inside checkConflictingAccountUpdateConditionForBranch(Accounts) in AccountsServiceImpl&quot; +</b>
&nbsp;                &quot;coming from %s&quot;, locality);
&nbsp;        Accounts.Branch newhomeBranch ;
<b class="fc">&nbsp;        newhomeBranch = (null == accountsDto) ? accounts.getHomeBranch() : accountsDto.getHomeBranch();</b>
<b class="fc">&nbsp;        Accounts.AccountType accountType = accounts.getAccountType();</b>
&nbsp;
&nbsp;        //get all accounts for customer
<b class="fc">&nbsp;        List&lt;Accounts&gt; listOfAccounts = accounts.getCustomer().getAccounts();</b>
&nbsp;
<b class="fc">&nbsp;        Accounts.Branch finalNewhomeBranch = newhomeBranch;</b>
<b class="fc">&nbsp;        boolean isNotPermissible = listOfAccounts.stream().</b>
<b class="fc">&nbsp;                anyMatch(account -&gt; finalNewhomeBranch.equals(account.getHomeBranch())</b>
<b class="fc">&nbsp;                        &amp;&amp; accountType.equals(account.getAccountType()));</b>
&nbsp;
<b class="fc">&nbsp;        if (isNotPermissible) throw new AccountsException(AccountsException.class,</b>
<b class="fc">&nbsp;                String.format(&quot;You already have an account with same accountType %s&quot; +</b>
&nbsp;                                &quot;and same HomeBranch %s&quot;,
<b class="fc">&nbsp;                        accounts.getAccountType(), accounts.getHomeBranch()), location);</b>
<b class="fc">&nbsp;        return true;</b>
&nbsp;    }
&nbsp;
&nbsp;    private Accounts processAccountInit(Accounts accounts, String req) throws AccountsException {
<b class="fc">&nbsp;        String methodName = &quot;processAccountInit(Accounts,String) in AccountsServiceImpl&quot;;</b>
&nbsp;        //If request is adding another accounts for a customer already have an account
&nbsp;        //there should not be two accounts with  same accountType in same homeBranch
<b class="fc">&nbsp;        if (req.equalsIgnoreCase(UPDATE)) {</b>
<b class="fc">&nbsp;            checkConflictingAccountUpdateConditionForBranch(accounts, null, methodName);</b>
&nbsp;        }
&nbsp;
&nbsp;        //initialize customer account opening balance
<b class="fc">&nbsp;        accounts.setBalance(0L);</b>
&nbsp;        //initialize branchCode
<b class="fc">&nbsp;        accounts.setBranchCode(getBranchCode(accounts.getHomeBranch()));</b>
&nbsp;        //initialize account status OPEN
<b class="fc">&nbsp;        accounts.setAccountStatus(STATUS_OPEN);</b>
&nbsp;        //initialize cash limit
<b class="fc">&nbsp;        accounts.setTransferLimitPerDay(100000L);</b>
&nbsp;
&nbsp;        //initialize loan fields
<b class="fc">&nbsp;        accounts.setTotLoanIssuedSoFar(0L);</b>
<b class="fc">&nbsp;        accounts.setTotalOutStandingAmountPayableToBank(0L);</b>
<b class="fc">&nbsp;        accounts.setAnyActiveLoans(false);</b>
&nbsp;        //credit score is 0 so approved limit should also be zero
<b class="fc">&nbsp;        accounts.setApprovedLoanLimitBasedOnCreditScore(0L);</b>
<b class="fc">&nbsp;        return accounts;</b>
&nbsp;    }
&nbsp;
&nbsp;    private Customer processCustomerInformation(Customer customer) {
&nbsp;        //set customer age from dob
<b class="fc">&nbsp;        LocalDate dob = customer.getDateOfBirth();</b>
<b class="fc">&nbsp;        int age = Period.between(dob, LocalDate.now()).getYears();</b>
<b class="fc">&nbsp;        customer.setAge(age);</b>
&nbsp;        //encode passwd
<b class="fc">&nbsp;        customer.setPassword(passwordEncoder.encode(customer.getPassword()));</b>
<b class="fc">&nbsp;        return customer;</b>
&nbsp;    }
&nbsp;
&nbsp;    private OutputDto createAccount(PostInputRequestDto postInputRequestDto) throws AccountsException {
<b class="fc">&nbsp;        Accounts account = inputToAccounts(postInputRequestDto);</b>
<b class="fc">&nbsp;        Customer customer = inputToCustomer(postInputRequestDto);</b>
<b class="fc">&nbsp;        account.setCustomer(customer);</b>
&nbsp;
<b class="fc">&nbsp;        updateValidator(account, mapToAccountsDto(account), null, CREATE_ACCOUNT);</b>
&nbsp;
<b class="fc">&nbsp;        Accounts processedAccount = processAccountInit(account, INIT);</b>
<b class="fc">&nbsp;        Customer processedCustomer = processCustomerInformation(customer);</b>
&nbsp;
&nbsp;        //add account to listOfAccounts of Customer &amp; register customer as the owner of this account
<b class="fc">&nbsp;        List&lt;Accounts&gt; listOfAccounts = new ArrayList&lt;&gt;();</b>
<b class="fc">&nbsp;        listOfAccounts.add(processedAccount);</b>
<b class="fc">&nbsp;        processedCustomer.setAccounts(listOfAccounts);</b>
<b class="fc">&nbsp;        processedAccount.setCustomer(processedCustomer);</b>
&nbsp;
&nbsp;        //save customer(parent) only , no need to save accounts(child) its auto saved due to cascadeType.All
&nbsp;        //thus reducing call to db
<b class="fc">&nbsp;        Customer savedCustomer = customerRepository.save(processedCustomer);</b>
&nbsp;
&nbsp;        //fetch the corresponding account of saved customer
<b class="fc">&nbsp;        Long accountNumber = savedCustomer.getAccounts().get(0).getAccountNumber();</b>
&nbsp;
<b class="fc">&nbsp;        return OutputDto.builder()</b>
<b class="fc">&nbsp;                .customer(mapToCustomerOutputDto(mapToCustomerDto(savedCustomer)))</b>
<b class="fc">&nbsp;                .accounts(mapToAccountsOutputDto(mapToAccountsDto(savedCustomer.getAccounts().get(0))))</b>
<b class="fc">&nbsp;                .defaultMessage(String.format(&quot;Account with id %s is created for customer %s&quot;, accountNumber, savedCustomer.getCustomerId()))</b>
<b class="fc">&nbsp;                .build();</b>
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;    private OutputDto createAccountForAlreadyCreatedUser(Long customerId, Accounts loadAccount, AccountsDto accountsDto) throws AccountsException {
<b class="fc">&nbsp;        String methodName = &quot;createAccountForAlreadyCreatedUser(Long,InoutDto) in AccountsServiceImpl&quot;;</b>
&nbsp;
<b class="fc">&nbsp;        Optional&lt;Customer&gt; customer = customerRepository.findById(customerId);</b>
<b class="fc">&nbsp;        if (customer.isEmpty()) {</b>
<b class="fc">&nbsp;            throw new AccountsException(AccountsException.class,</b>
<b class="fc">&nbsp;                    String.format(&quot;No such customers with id %s found&quot;, customerId),</b>
&nbsp;                    methodName);
&nbsp;        }
<b class="fc">&nbsp;        loadAccount.setCustomer(customer.get());</b>
&nbsp;        //validate
<b class="fc">&nbsp;        updateValidator(loadAccount, accountsDto, null, ADD_ACCOUNT);</b>
&nbsp;        //some critical processing
<b class="fc">&nbsp;        Accounts accounts = mapToAccounts(accountsDto);</b>
&nbsp;        //register this customer as the owner of this account
<b class="fc">&nbsp;        accounts.setCustomer(customer.get());</b>
<b class="fc">&nbsp;        Accounts processedAccount = processAccountInit(accounts, UPDATE);</b>
&nbsp;        //save it bebe
<b class="fc">&nbsp;        Accounts savedAccount = accountsRepository.save(processedAccount);</b>
&nbsp;
<b class="fc">&nbsp;        return OutputDto.builder()</b>
<b class="fc">&nbsp;                .customer(mapToCustomerOutputDto(mapToCustomerDto(customer.get())))</b>
<b class="fc">&nbsp;                .accounts(mapToAccountsOutputDto(mapToAccountsDto(savedAccount)))</b>
<b class="fc">&nbsp;                .defaultMessage(String.format(&quot;New account with id %s is created for customer with id:%s&quot;, savedAccount.getAccountNumber(), customerId))</b>
<b class="fc">&nbsp;                .build();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @param accountNumber accountNumber
&nbsp;     * @paramType Long
&nbsp;     * @returnType AccountsDto
&nbsp;     */
&nbsp;    private OutputDto getAccountInfo(Long accountNumber) throws AccountsException {
<b class="fc">&nbsp;        Accounts foundAccount = fetchAccountByAccountNumber(accountNumber);</b>
<b class="fc">&nbsp;        Customer foundCustomer = foundAccount.getCustomer();</b>
&nbsp;
<b class="fc">&nbsp;        return OutputDto.builder()</b>
<b class="fc">&nbsp;                .customer(mapToCustomerOutputDto(mapToCustomerDto(foundCustomer)))</b>
<b class="fc">&nbsp;                .accounts(mapToAccountsOutputDto(mapToAccountsDto(foundAccount)))</b>
<b class="fc">&nbsp;                .defaultMessage(String.format(&quot;Retrieved info about account with id: %s&quot;, foundAccount.getAccountNumber()))</b>
<b class="fc">&nbsp;                .build();</b>
&nbsp;    }
&nbsp;
&nbsp;    private PageableResponseDto&lt;AccountsDto&gt; getAllActiveAccountsByCustomerId(Long customerId, Pageable pageable) throws AccountsException {
<b class="fc">&nbsp;        String methodName = &quot;getAllAccountsByCustomerId(Long) in AccountsServiceImpl&quot;;</b>
<b class="fc">&nbsp;        Optional&lt;Page&lt;Accounts&gt;&gt; allPagedAccounts = accountsRepository.findAllByCustomer_CustomerId(customerId, pageable);</b>
<b class="fc">&nbsp;        if (allPagedAccounts.isEmpty())</b>
<b class="nc">&nbsp;            throw new AccountsException(AccountsException.class,</b>
<b class="nc">&nbsp;                    String.format(&quot;No such accounts present with this customer %s&quot;, customerId), methodName);</b>
&nbsp;
<b class="fc">&nbsp;        return getPageableResponse(allPagedAccounts.get(), AccountsDto.class);</b>
&nbsp;    }
&nbsp;
&nbsp;    private Boolean updateValidator(Accounts accounts, AccountsDto accountsDto, CustomerDto customerDto, ValidateType request) throws AccountsException {
<b class="fc">&nbsp;        String methodName = &quot;updateValidator(Accounts,ValidateType) in AccountsServiceImpl&quot;;</b>
<b class="fc">&nbsp;        String location = &quot;&quot;;</b>
<b class="fc">&nbsp;        switch (request) {</b>
&nbsp;            case CREATE_ACC -&gt; {
<b class="fc">&nbsp;                location = &quot;Inside CREATE_ACC&quot;;</b>
&nbsp;                //check whether such account owner is already present
<b class="fc">&nbsp;                List&lt;Accounts&gt; accountsList = accountsRepository.findAll();</b>
&nbsp;                //if no accounts by far then certainly we can add
<b class="fc">&nbsp;                if (accountsList.isEmpty()) return true;</b>
&nbsp;
<b class="fc">&nbsp;                String adharNumber = accounts.getCustomer().getAdharNumber();</b>
<b class="fc">&nbsp;                boolean isNotPossible = accountsList.stream().anyMatch(acc -&gt; adharNumber.equalsIgnoreCase(acc.getCustomer().getAdharNumber()));</b>
<b class="fc">&nbsp;                if (isNotPossible)</b>
<b class="fc">&nbsp;                    throw new AccountsException(AccountsException.class, String.format(&quot;You already have an account with adhar:%s&quot;, adharNumber),</b>
<b class="fc">&nbsp;                            String.format(&quot;%s of %s&quot;, location, methodName));</b>
<b class="nc">&nbsp;            }</b>
&nbsp;            case ADD_ACC -&gt; {
<b class="fc">&nbsp;                location = &quot;Inside ADD_ACC&quot;;</b>
<b class="fc">&nbsp;                final int MAX_PERMISSIBLE_ACCOUNT=5;</b>
&nbsp;                //prevent a customer to create more than 10 accounts
<b class="fc">&nbsp;                Customer customer = accounts.getCustomer();</b>
<b class="fc">&nbsp;                if (customer.getAccounts().size() &gt;= MAX_PERMISSIBLE_ACCOUNT) throw new AccountsException(AccountsException.class,</b>
&nbsp;                        &quot;You can;t have more than 10 accounts&quot;,
<b class="fc">&nbsp;                        String.format(&quot;%s of %s&quot;, location, methodName));</b>
<b class="fc">&nbsp;            }</b>
&nbsp;            case UPDATE_CASH_LIMIT -&gt; {
<b class="fc">&nbsp;                return Period.between(accounts.getCreatedDate(), LocalDate.now()).getMonths() &gt;= 6;</b>
&nbsp;            }
&nbsp;            case UPLOAD_PROFILE_IMAGE -&gt; {
<b class="fc">&nbsp;                location = &quot;Inside UPLOAD_PROFILE_IMAGE&quot;;</b>
<b class="fc">&nbsp;                if (null == customerDto.getCustomerImage()) throw new BadApiRequestException(BadApiRequestException.class,</b>
<b class="nc">&nbsp;                        &quot;Please provide image&quot;, String.format(&quot;%s of %s&quot;, methodName, location));</b>
<b class="fc">&nbsp;                double FIlE_SIZE_TO_MB_CONVERTER_FACTOR = 0.00000095367432;</b>
<b class="fc">&nbsp;                if (customerDto.getCustomerImage().getSize() * FIlE_SIZE_TO_MB_CONVERTER_FACTOR &lt;= 0.0 || customerDto.getCustomerImage().getSize() * FIlE_SIZE_TO_MB_CONVERTER_FACTOR &gt; 100.0)</b>
<b class="nc">&nbsp;                    throw new BadApiRequestException(BadApiRequestException.class,</b>
&nbsp;                            &quot;Your file is either corrupted or you are exceeding the max size of 100mb&quot;,
<b class="nc">&nbsp;                            String.format(&quot;%s of %s&quot;, methodName, location));</b>
<b class="fc">&nbsp;            }</b>
&nbsp;            case UPDATE_HOME_BRANCH -&gt; {
<b class="fc">&nbsp;                location = &quot;Inside UPDATE_HOME_BRANCH&quot;;</b>
<b class="fc">&nbsp;                return checkConflictingAccountUpdateConditionForBranch(accounts,</b>
<b class="fc">&nbsp;                        accountsDto, String.format(&quot;%s of %s&quot;, location, methodName));</b>
&nbsp;            }
&nbsp;            case CLOSE_ACCOUNT -&gt; {
<b class="fc">&nbsp;                AccountStatus status = accounts.getAccountStatus();</b>
<b class="fc">&nbsp;                switch (status) {</b>
&nbsp;                    case CLOSED -&gt;
<b class="nc">&nbsp;                            throw new AccountsException(AccountsException.class, String.format(&quot;Account: %s is already closed&quot;, accounts.getAccountNumber()), location);</b>
&nbsp;                    case BLOCKED -&gt;
<b class="nc">&nbsp;                            throw new AccountsException(AccountsException.class, String.format(&quot;Cant perform anything on Blocked account:%s&quot;, accounts.getAccountNumber()), location);</b>
&nbsp;                    case OPEN -&gt; {
<b class="fc">&nbsp;                        return accounts.getAnyActiveLoans();</b>
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;            case RE_OPEN_ACCOUNT -&gt; {
<b class="fc">&nbsp;                AccountStatus status = accounts.getAccountStatus();</b>
<b class="fc">&nbsp;                switch (status) {</b>
&nbsp;                    case CLOSED -&gt; {
<b class="fc">&nbsp;                        return true;</b>
&nbsp;                    }
&nbsp;                    case BLOCKED -&gt;
<b class="nc">&nbsp;                            throw new AccountsException(AccountsException.class, String.format(&quot;Cant perform anything on Blocked account:%s&quot;, accounts.getAccountNumber()), location);</b>
&nbsp;                    case OPEN -&gt;
<b class="nc">&nbsp;                            throw new AccountsException(AccountsException.class, String.format(&quot;Status of Account: %s is already Open&quot;, accounts.getAccountNumber()), location);</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;            case BLOCK_ACCOUNT -&gt; {
<b class="fc">&nbsp;                if (accounts.getAccountStatus().equals(STATUS_BLOCKED))</b>
<b class="nc">&nbsp;                    throw new AccountsException(AccountsException.class,</b>
<b class="nc">&nbsp;                            String.format(&quot;Status of Account: %s is already Blocked&quot;,</b>
<b class="nc">&nbsp;                                    accounts.getAccountStatus()), location);</b>
<b class="fc">&nbsp;                return true;</b>
&nbsp;            }
&nbsp;        }
<b class="fc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    private Accounts updateHomeBranch(AccountsDto accountsDto, Accounts accounts) throws AccountsException {
<b class="fc">&nbsp;        Accounts.Branch oldHomeBranch = accounts.getHomeBranch();</b>
<b class="fc">&nbsp;        Accounts.Branch newHomeBranch = accountsDto.getHomeBranch();</b>
<b class="fc">&nbsp;        Accounts savedUpdatedAccount = accounts;</b>
&nbsp;
<b class="fc">&nbsp;        if (updateValidator(accounts, accountsDto, null, UPDATE_HOME_BRANCH)</b>
<b class="fc">&nbsp;                &amp;&amp; null != newHomeBranch &amp;&amp; !newHomeBranch.equals(oldHomeBranch)) {</b>
<b class="fc">&nbsp;            accounts.setHomeBranch(newHomeBranch);</b>
<b class="fc">&nbsp;            accounts.setBranchCode(getBranchCode(newHomeBranch));</b>
<b class="fc">&nbsp;            savedUpdatedAccount = accountsRepository.save(accounts);</b>
&nbsp;        }
<b class="fc">&nbsp;        return savedUpdatedAccount;</b>
&nbsp;    }
&nbsp;
&nbsp;    private Accounts increaseTransferLimit(AccountsDto accountsDto, Accounts accounts) throws AccountsException {
<b class="fc">&nbsp;        String methodName = &quot;increaseTransferLimit(AccountsDto,Accounts) in AccountsServiceImpl&quot;;</b>
<b class="fc">&nbsp;        Long oldCashLimit = accounts.getTransferLimitPerDay();</b>
<b class="fc">&nbsp;        Long newCashLimit = accountsDto.getTransferLimitPerDay();</b>
&nbsp;
<b class="fc">&nbsp;        Accounts savedAccount = accounts;</b>
<b class="fc">&nbsp;        if (null != newCashLimit &amp;&amp; !newCashLimit.equals(oldCashLimit)) {</b>
<b class="fc">&nbsp;            if (updateValidator(accounts, accountsDto, null, UPDATE_CASH_LIMIT))</b>
<b class="fc">&nbsp;                accounts.setTransferLimitPerDay(newCashLimit);</b>
&nbsp;            else
<b class="fc">&nbsp;                throw new AccountsException(AccountsException.class,</b>
<b class="fc">&nbsp;                        String.format(&quot;Yr Account with id %s must be at least &quot; +</b>
<b class="fc">&nbsp;                                &quot;six months old &quot;, accounts.getAccountNumber()), methodName);</b>
<b class="fc">&nbsp;            savedAccount = accountsRepository.save(accounts);</b>
&nbsp;        }
<b class="fc">&nbsp;        return savedAccount;</b>
&nbsp;    }
&nbsp;
&nbsp;    private void blockAccount(Accounts foundAccount) throws AccountsException {
&nbsp;        //Note: block is very urgent so no prior validation is required  for ongoing loan
&nbsp;        //but authority reserves right to scrutiny any ongoing loan Emi
&nbsp;
<b class="fc">&nbsp;        updateValidator(foundAccount, mapToAccountsDto(foundAccount), null, BLOCK_ACCOUNT);</b>
&nbsp;        //Block it
<b class="fc">&nbsp;        foundAccount.setAccountStatus(STATUS_BLOCKED);</b>
&nbsp;        //save it
<b class="fc">&nbsp;        accountsRepository.save(foundAccount);</b>
&nbsp;    }
&nbsp;
&nbsp;    private void closeAccount(Accounts foundAccount) throws AccountsException {
<b class="fc">&nbsp;        String methodName = &quot;closeAccount(accountNUmber) in AccountsServiceImpl&quot;;</b>
&nbsp;        //check if he has pending loan
<b class="fc">&nbsp;        if (updateValidator(foundAccount, mapToAccountsDto(foundAccount), null, CLOSE_ACCOUNT))</b>
<b class="nc">&nbsp;            throw new AccountsException(AccountsException.class, String.format(&quot;This account with id %s still has &quot; +</b>
<b class="nc">&nbsp;                    &quot;running loan. Please consider paying it before closing&quot;, foundAccount.getAccountNumber()), methodName);</b>
&nbsp;        //close it
<b class="fc">&nbsp;        foundAccount.setAccountStatus(STATUS_CLOSED);</b>
&nbsp;        //save it
<b class="fc">&nbsp;        accountsRepository.save(foundAccount);</b>
&nbsp;    }
&nbsp;
&nbsp;    private void unCloseAccount(Accounts account) throws AccountsException {
<b class="fc">&nbsp;        if (updateValidator(account, mapToAccountsDto(account), null, RE_OPEN_ACCOUNT)) {</b>
<b class="fc">&nbsp;            account.setAccountStatus(STATUS_OPEN);</b>
<b class="fc">&nbsp;            accountsRepository.save(account);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void deleteAccount(Long accountNumber) throws AccountsException {
&nbsp;        //checking whether account exist or not
<b class="fc">&nbsp;        fetchAccountByAccountNumber(accountNumber);</b>
&nbsp;        //deleting it
<b class="fc">&nbsp;        accountsRepository.deleteByAccountNumber(accountNumber);</b>
&nbsp;    }
&nbsp;
&nbsp;    private void deleteAllAccountsByCustomer(Long customerId) throws AccountsException {
<b class="fc">&nbsp;        String methodName = &quot;deleteAllAccountsByCustomer(Long ) in AccountsServiceImpl&quot;;</b>
&nbsp;        //checking whether customer exist
<b class="fc">&nbsp;        Optional&lt;Customer&gt; foundCustomer = customerRepository.findById(customerId);</b>
&nbsp;
<b class="fc">&nbsp;        if (foundCustomer.isEmpty())</b>
<b class="nc">&nbsp;            throw new AccountsException(AccountsException.class, String.format(&quot;No such customer exists with id %s&quot;, customerId), methodName);</b>
&nbsp;        //deleting it
<b class="fc">&nbsp;        accountsRepository.deleteAllByCustomer_CustomerId(customerId);</b>
&nbsp;    }
&nbsp;
&nbsp;    private Customer updateCustomerDetails(Customer oldCustomerRecord, CustomerDto newCustomerRecord) {
<b class="fc">&nbsp;        String oldName = oldCustomerRecord.getName();</b>
<b class="fc">&nbsp;        String newName = newCustomerRecord.getCustomerName();</b>
&nbsp;
<b class="fc">&nbsp;        LocalDate oldDateOfBirth = oldCustomerRecord.getDateOfBirth();</b>
<b class="fc">&nbsp;        LocalDate newDateOfBirth = newCustomerRecord.getDateOfBirth();</b>
&nbsp;
<b class="fc">&nbsp;        int newAge = Period.between(newDateOfBirth, LocalDate.now()).getYears();</b>
&nbsp;
<b class="fc">&nbsp;        String oldEmail = oldCustomerRecord.getEmail();</b>
<b class="fc">&nbsp;        String newEmail = newCustomerRecord.getEmail();</b>
&nbsp;
<b class="fc">&nbsp;        String oldPhoneNumber = oldCustomerRecord.getPhoneNumber();</b>
<b class="fc">&nbsp;        String newPhoneNumber = newCustomerRecord.getPhoneNumber();</b>
&nbsp;
<b class="fc">&nbsp;        String oldAdharNumber = oldCustomerRecord.getAdharNumber();</b>
<b class="fc">&nbsp;        String newAdharNumber = newCustomerRecord.getAdharNumber();</b>
&nbsp;
<b class="fc">&nbsp;        String oldPanNumber = oldCustomerRecord.getPanNumber();</b>
<b class="fc">&nbsp;        String newPanNumber = newCustomerRecord.getPanNumber();</b>
&nbsp;
<b class="fc">&nbsp;        String voterId = oldCustomerRecord.getVoterId();</b>
<b class="fc">&nbsp;        String newVoterId = newCustomerRecord.getVoterId();</b>
&nbsp;
<b class="fc">&nbsp;        String oldDrivingLicense = oldCustomerRecord.getDrivingLicense();</b>
<b class="fc">&nbsp;        String newDrivingLicense = newCustomerRecord.getDrivingLicense();</b>
&nbsp;
<b class="fc">&nbsp;        String oldPassportNumber = oldCustomerRecord.getPassportNumber();</b>
<b class="fc">&nbsp;        String newPassportNumber = newCustomerRecord.getPassportNumber();</b>
&nbsp;
<b class="fc">&nbsp;        if (null!=newName &amp;&amp; !oldName.equalsIgnoreCase(newName))</b>
<b class="fc">&nbsp;            newCustomerRecord.setCustomerName(newName);</b>
<b class="fc">&nbsp;        if (null!=newDateOfBirth &amp;&amp; !oldDateOfBirth.equals(newDateOfBirth)) {</b>
<b class="fc">&nbsp;            newCustomerRecord.setDateOfBirth(newDateOfBirth);</b>
<b class="fc">&nbsp;            newCustomerRecord.setAge(newAge);</b>
&nbsp;        }
<b class="fc">&nbsp;        if (null!=newEmail &amp;&amp; !oldEmail.equalsIgnoreCase(newEmail))</b>
<b class="fc">&nbsp;            newCustomerRecord.setEmail(newEmail);</b>
<b class="fc">&nbsp;        if (null!=newPhoneNumber &amp;&amp; !oldPhoneNumber.equalsIgnoreCase(newPhoneNumber))</b>
<b class="fc">&nbsp;            newCustomerRecord.setCustomerName(newPhoneNumber);</b>
<b class="fc">&nbsp;        if (null!=newAdharNumber &amp;&amp; !oldAdharNumber.equalsIgnoreCase(newAdharNumber))</b>
<b class="fc">&nbsp;            newCustomerRecord.setCustomerName(newAdharNumber);</b>
<b class="fc">&nbsp;        if (null!=newPassportNumber &amp;&amp; !oldPassportNumber.equalsIgnoreCase(newPassportNumber))</b>
<b class="fc">&nbsp;            newCustomerRecord.setCustomerName(newPassportNumber);</b>
<b class="fc">&nbsp;        if (null!=newPanNumber &amp;&amp; !oldPanNumber.equalsIgnoreCase(newPanNumber))</b>
<b class="fc">&nbsp;            newCustomerRecord.setCustomerName(newPanNumber);</b>
<b class="fc">&nbsp;        if (null!=newVoterId &amp;&amp; !voterId.equalsIgnoreCase(newVoterId))</b>
<b class="fc">&nbsp;            newCustomerRecord.setCustomerName(newVoterId);</b>
<b class="fc">&nbsp;        if (null!=newDrivingLicense &amp;&amp; !oldDrivingLicense.equalsIgnoreCase(newDrivingLicense))</b>
<b class="fc">&nbsp;            newCustomerRecord.setDrivingLicense(newDrivingLicense);</b>
&nbsp;
<b class="fc">&nbsp;        Customer updatedCustomer = mapToCustomer(newCustomerRecord);</b>
&nbsp;
&nbsp;        //auditing does not work during update so manually set it
<b class="fc">&nbsp;        updatedCustomer.setCreatedBy(&quot;Admin&quot;);</b>
<b class="fc">&nbsp;        return customerRepository.save(updatedCustomer);</b>
&nbsp;    }
&nbsp;
&nbsp;    private int getCreditScore(Long accountNumber) {
&nbsp;        ///to be done
<b class="nc">&nbsp;        return 0;</b>
&nbsp;    }
&nbsp;
&nbsp;    private int updateCreditScore(AccountsDto accountsDto) {
<b class="nc">&nbsp;        return 0;</b>
&nbsp;    }
&nbsp;
&nbsp;    private PageableResponseDto&lt;AccountsDto&gt; accountsPagination(DIRECTION sortDir,String sortBy,int pageNumber,int pageSize,Long customerId) {
<b class="fc">&nbsp;        String methodName=&quot;accountsPagination(DIRECTION,String,int,int,Long) in AccountsServiceImpl&quot;;</b>
<b class="fc">&nbsp;        Sort sort = sortDir.equals(PAGE_SORT_DIRECTION_ASCENDING) ? Sort.by(sortBy).ascending() : Sort.by(sortBy).descending();</b>
<b class="fc">&nbsp;        Pageable pageable = PageRequest.of(pageNumber, pageSize, sort);</b>
<b class="fc">&nbsp;        PageableResponseDto&lt;AccountsDto&gt; pageableResponseDto = getAllActiveAccountsByCustomerId(customerId, pageable);</b>
<b class="fc">&nbsp;        if (pageableResponseDto.getContent().size() == 0)</b>
<b class="nc">&nbsp;            throw new BadApiRequestException(BadApiRequestException.class,</b>
<b class="nc">&nbsp;                    String.format(&quot;Customer with id %s have no accounts present&quot;, customerId),</b>
&nbsp;                    methodName);
&nbsp;
<b class="fc">&nbsp;        List&lt;AccountsDto&gt; onlyActiveAccounts = pageableResponseDto.getContent().stream().filter(accounts -&gt; !STATUS_BLOCKED.equals(accounts.getAccountStatus())</b>
<b class="fc">&nbsp;                &amp;&amp; !STATUS_CLOSED.equals(accounts.getAccountStatus())).toList();</b>
&nbsp;
<b class="fc">&nbsp;        pageableResponseDto.setContent(onlyActiveAccounts);</b>
<b class="fc">&nbsp;        return  pageableResponseDto;</b>
&nbsp;    }
&nbsp;
&nbsp;    private void uploadProfileImage(CustomerDto customerDto) throws IOException {
<b class="fc">&nbsp;        updateValidator(null, null, customerDto, UPLOAD_PROFILE_IMAGE);</b>
<b class="fc">&nbsp;        String imageName = fIleService.uploadFile(customerDto.getCustomerImage(), IMAGE_PATH);</b>
<b class="fc">&nbsp;        Customer customer = fetchCustomerByCustomerNumber(customerDto.getCustomerId());</b>
<b class="fc">&nbsp;        customer.setImageName(imageName);</b>
<b class="fc">&nbsp;        customerRepository.save(customer);</b>
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;    /**
&nbsp;     * @param postInputRequestDto
&nbsp;     * @return
&nbsp;     */
&nbsp;    @Override
&nbsp;    public OutputDto accountSetUp(PostInputRequestDto postInputRequestDto) {
<b class="fc">&nbsp;        return createAccount(postInputRequestDto);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public OutputDto postRequestExecutor(PostInputRequestDto postInputRequestDto) throws AccountsException, CustomerException {
<b class="fc">&nbsp;        String methodName = &quot;postRequestExecutor(InputDto) in AccountsServiceImpl&quot;;</b>
&nbsp;        //map
<b class="fc">&nbsp;        AccountsDto accountsDto = inputToAccountsDto(postInputRequestDto);</b>
<b class="fc">&nbsp;        CustomerDto customerDto = inputToCustomerDto(postInputRequestDto);</b>
&nbsp;
&nbsp;        //Get the accountNumber &amp; account &amp; customer
<b class="fc">&nbsp;        Long accountNumber = accountsDto.getAccountNumber();</b>
&nbsp;        Accounts foundAccount;
<b class="fc">&nbsp;        if (null!=accountNumber) foundAccount = fetchAccountByAccountNumber(accountNumber);</b>
&nbsp;
<b class="fc">&nbsp;        Long customerId = customerDto.getCustomerId();</b>
&nbsp;        Customer foundCustomer;
<b class="fc">&nbsp;        if (null!=customerId) foundCustomer = fetchCustomerByCustomerNumber(customerId);</b>
&nbsp;        //check the request type
<b class="fc">&nbsp;        if (null == accountsDto.getUpdateRequest())</b>
<b class="nc">&nbsp;            throw new AccountsException(AccountsException.class, &quot;update request field must not be blank&quot;, methodName);</b>
<b class="fc">&nbsp;        AccountsDto.UpdateRequest request = accountsDto.getUpdateRequest();</b>
<b class="fc">&nbsp;        switch (request) {</b>
&nbsp;            case LEND_LOAN -&gt; {
&nbsp;                //to be done...
<b class="nc">&nbsp;                return OutputDto.builder().defaultMessage(&quot;Baad main karenge&quot;).build();</b>
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            default -&gt; throw new AccountsException(AccountsException.class,</b>
<b class="fc">&nbsp;                    String.format(&quot;Invalid request type %s for POST requests&quot;, request),</b>
&nbsp;                    methodName);
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public OutputDto getRequestExecutor(GetInputRequestDto getInputRequestDto) throws AccountsException, CustomerException {
<b class="fc">&nbsp;        String methodName = &quot;getRequestExecutor(InputDto) in AccountsServiceImpl&quot;;</b>
&nbsp;
&nbsp;
&nbsp;        //get paging details
<b class="fc">&nbsp;        int pageNumber = getInputRequestDto.getPageNumber();</b>
<b class="fc">&nbsp;        if (pageNumber &lt; 0) throw new BadApiRequestException(BadApiRequestException.class,</b>
&nbsp;                &quot;pageNumber cant be in negative&quot;, methodName);
&nbsp;
<b class="fc">&nbsp;        int pageSize = getInputRequestDto.getPageSize();</b>
<b class="fc">&nbsp;        if (pageSize &lt; 0)</b>
<b class="nc">&nbsp;            throw new BadApiRequestException(BadApiRequestException.class, &quot;Page Size can&#39;t be in negative&quot;, methodName);</b>
<b class="fc">&nbsp;        pageSize = (getInputRequestDto.getPageSize() == 0) ? DEFAULT_PAGE_SIZE : getInputRequestDto.getPageSize();</b>
&nbsp;
<b class="fc">&nbsp;        String sortBy = (null == getInputRequestDto.getSortBy()) ? &quot;balance&quot; : getInputRequestDto.getSortBy();</b>
<b class="fc">&nbsp;        DIRECTION sortDir = (null == getInputRequestDto.getSortDir()) ? DIRECTION.asc : getInputRequestDto.getSortDir();</b>
&nbsp;
&nbsp;
&nbsp;        //map
<b class="fc">&nbsp;        AccountsDto accountsDto = getInputToAccountsDto(getInputRequestDto);</b>
<b class="fc">&nbsp;        CustomerDto customerDto = getInputToCustomerDto(getInputRequestDto);</b>
&nbsp;        //load accounts &amp; customer
<b class="fc">&nbsp;        Long accountNumber = accountsDto.getAccountNumber();</b>
<b class="fc">&nbsp;        Accounts foundAccount = null;</b>
<b class="fc">&nbsp;        if (Objects.nonNull(accountNumber)) foundAccount = fetchAccountByAccountNumber(accountNumber);</b>
&nbsp;
<b class="fc">&nbsp;        Long customerId = customerDto.getCustomerId();</b>
<b class="fc">&nbsp;        Customer foundCustomer = null;</b>
<b class="fc">&nbsp;        if (Objects.nonNull(customerId)) foundCustomer = fetchCustomerByCustomerNumber(customerId);</b>
&nbsp;
&nbsp;        //check the request type
<b class="fc">&nbsp;        if (null == accountsDto.getUpdateRequest())</b>
<b class="nc">&nbsp;            throw new AccountsException(AccountsException.class, &quot;update request field must not be blank&quot;, methodName);</b>
<b class="fc">&nbsp;        AccountsDto.UpdateRequest request = accountsDto.getUpdateRequest();</b>
<b class="fc">&nbsp;        switch (request) {</b>
&nbsp;            case GET_CREDIT_SCORE -&gt; {
<b class="nc">&nbsp;                getCreditScore(accountNumber);</b>
&nbsp;                //to be done after implementing credit card microservice
<b class="nc">&nbsp;                return OutputDto.builder().defaultMessage(&quot;Baad main karenge&quot;).build();</b>
&nbsp;            }
&nbsp;            case GET_ACC_INFO -&gt; {
<b class="fc">&nbsp;                return getAccountInfo(accountNumber);</b>
&nbsp;            }
&nbsp;            case GET_ALL_ACC -&gt; {
<b class="fc">&nbsp;                String locality = String.format(&quot;Inside switch ,for GET_ALL_ACC case under method %s&quot;, methodName);</b>
<b class="fc">&nbsp;                if (null == foundCustomer) throw new CustomerException(CustomerException.class, locality, methodName);</b>
&nbsp;
&nbsp;                //validate the genuineness of sorting fields
<b class="fc">&nbsp;                Set&lt;String&gt; allPageableFieldsOfAccounts = getAllPageableFieldsOfAccounts();</b>
<b class="fc">&nbsp;                if (!allPageableFieldsOfAccounts.contains(sortBy))</b>
<b class="nc">&nbsp;                    throw new BadApiRequestException(BadApiRequestException.class,</b>
<b class="nc">&nbsp;                            String.format(&quot;%s is not a valid field of account&quot;, sortBy), String.format(&quot;Inside %s of %s&quot;, locality, methodName));</b>
&nbsp;                //paging &amp; sorting
<b class="fc">&nbsp;                PageableResponseDto&lt;AccountsDto&gt; pageableResponseDto=accountsPagination(sortDir,sortBy,pageNumber,pageSize,customerId);</b>
&nbsp;
<b class="fc">&nbsp;                return OutputDto.builder()</b>
<b class="fc">&nbsp;                        .customer(mapToCustomerOutputDto(mapToCustomerDto(foundCustomer)))</b>
<b class="fc">&nbsp;                        .accountsListPages(pageableResponseDto)</b>
<b class="fc">&nbsp;                        .defaultMessage(String.format(&quot;Fetched all accounts for customer id:%s&quot;, customerId))</b>
<b class="fc">&nbsp;                        .build();</b>
&nbsp;            }
&nbsp;            default -&gt;
<b class="fc">&nbsp;                    throw new AccountsException(AccountsException.class, String.format(&quot;Invalid request type %s for GET request&quot;, request), methodName);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public OutputDto putRequestExecutor(PutInputRequestDto putInputRequestDto) throws AccountsException, CustomerException, IOException {
<b class="fc">&nbsp;        String methodName = &quot;putRequestExecutor(InputDto) in AccountsServiceImpl&quot;;</b>
&nbsp;        //map
<b class="fc">&nbsp;        AccountsDto accountsDto = putInputRequestToAccountsDto(putInputRequestDto);</b>
<b class="fc">&nbsp;        CustomerDto customerDto = putInputRequestToCustomerDto(putInputRequestDto);</b>
&nbsp;
&nbsp;        //get paging details
<b class="fc">&nbsp;        int pageNumber = putInputRequestDto.getPageNumber();</b>
<b class="fc">&nbsp;        if (pageNumber &lt; 0) throw new BadApiRequestException(BadApiRequestException.class,</b>
&nbsp;                &quot;pageNumber cant be in negative&quot;, methodName);
&nbsp;
<b class="fc">&nbsp;        int pageSize = putInputRequestDto.getPageSize();</b>
<b class="fc">&nbsp;        if (pageSize &lt; 0)</b>
<b class="nc">&nbsp;            throw new BadApiRequestException(BadApiRequestException.class, &quot;Page Size can&#39;t be in negative&quot;, methodName);</b>
<b class="fc">&nbsp;        pageSize = (putInputRequestDto.getPageSize() == 0) ? DEFAULT_PAGE_SIZE : putInputRequestDto.getPageSize();</b>
&nbsp;
<b class="fc">&nbsp;        String sortBy = (null == putInputRequestDto.getSortBy()) ? &quot;balance&quot; : putInputRequestDto.getSortBy();</b>
<b class="fc">&nbsp;        DIRECTION sortDir = (null == putInputRequestDto.getSortDir()) ? DIRECTION.asc : putInputRequestDto.getSortDir();</b>
&nbsp;
&nbsp;
&nbsp;        //Get the accountNumber &amp; account &amp; customer
<b class="fc">&nbsp;        Long accountNumber = accountsDto.getAccountNumber();</b>
<b class="fc">&nbsp;        Accounts foundAccount = null;</b>
<b class="fc">&nbsp;        if (Objects.nonNull(accountNumber)) foundAccount = fetchAccountByAccountNumber(accountNumber);</b>
&nbsp;
<b class="fc">&nbsp;        Long customerId = customerDto.getCustomerId();</b>
<b class="fc">&nbsp;        Customer foundCustomer = null;</b>
<b class="fc">&nbsp;        if (Objects.nonNull(customerId)) foundCustomer = fetchCustomerByCustomerNumber(customerId);</b>
&nbsp;
&nbsp;        //check the request type
<b class="fc">&nbsp;        if (null == accountsDto.getUpdateRequest())</b>
<b class="nc">&nbsp;            throw new AccountsException(AccountsException.class, &quot;update request field must not be blank&quot;, methodName);</b>
<b class="fc">&nbsp;        AccountsDto.UpdateRequest request = accountsDto.getUpdateRequest();</b>
<b class="fc">&nbsp;        switch (request) {</b>
&nbsp;            case ADD_ACCOUNT -&gt; {
<b class="fc">&nbsp;                return createAccountForAlreadyCreatedUser(customerDto.getCustomerId(), mapToAccounts(accountsDto), accountsDto);</b>
&nbsp;            }
&nbsp;            case UPDATE_HOME_BRANCH -&gt; {
<b class="fc">&nbsp;                Accounts updatedAccount = updateHomeBranch(accountsDto, foundAccount);</b>
&nbsp;
<b class="fc">&nbsp;                return OutputDto.builder()</b>
<b class="fc">&nbsp;                        .customer(mapToCustomerOutputDto(mapToCustomerDto(updatedAccount.getCustomer())))</b>
<b class="fc">&nbsp;                        .accounts(mapToAccountsOutputDto(mapToAccountsDto(updatedAccount)))</b>
<b class="fc">&nbsp;                        .defaultMessage(String.format(&quot;Home branch is changed from %s to %s for customer with id %s&quot;,</b>
<b class="fc">&nbsp;                                foundAccount.getHomeBranch(), accountsDto.getHomeBranch(), foundAccount.getCustomer().getCustomerId()))</b>
<b class="fc">&nbsp;                        .build();</b>
&nbsp;            }
&nbsp;            case UPDATE_CREDIT_SCORE -&gt; {
&nbsp;                //updateCreditScore(accountsDto);
<b class="nc">&nbsp;                return OutputDto.builder().defaultMessage(&quot;Baad main karenge&quot;).build();</b>
&nbsp;            }
&nbsp;            case UPLOAD_CUSTOMER_IMAGE -&gt; {
<b class="fc">&nbsp;                uploadProfileImage(customerDto);</b>
<b class="fc">&nbsp;                return OutputDto.builder().customer(mapToCustomerOutputDto(mapToCustomerDto(foundCustomer)))</b>
<b class="fc">&nbsp;                        .defaultMessage(String.format(&quot;Profile Image for customer with id:%s has been updated successfully&quot;, customerDto.getCustomerId()))</b>
<b class="fc">&nbsp;                        .build();</b>
&nbsp;            }
&nbsp;            case INC_TRANSFER_LIMIT -&gt; {
<b class="fc">&nbsp;                Accounts accountWithUpdatedLimit = increaseTransferLimit(accountsDto, foundAccount);</b>
<b class="fc">&nbsp;                return OutputDto.builder()</b>
<b class="fc">&nbsp;                        .customer(mapToCustomerOutputDto(customerDto))</b>
<b class="fc">&nbsp;                        .accounts(mapToAccountsOutputDto(mapToAccountsDto(accountWithUpdatedLimit)))</b>
<b class="fc">&nbsp;                        .defaultMessage(String.format(&quot;Transfer Limit has been increased from %s to %s&quot;, foundAccount.getTransferLimitPerDay(), accountWithUpdatedLimit.getTransferLimitPerDay()))</b>
<b class="fc">&nbsp;                        .build();</b>
&nbsp;            }
&nbsp;            case CLOSE_ACC -&gt; {
<b class="fc">&nbsp;                closeAccount(foundAccount);</b>
<b class="fc">&nbsp;                return OutputDto.builder()</b>
<b class="fc">&nbsp;                        .defaultMessage(String.format(&quot;Account with id %s is successfully closed&quot;, accountsDto.getAccountNumber()))</b>
<b class="fc">&nbsp;                        .build();</b>
&nbsp;            }
&nbsp;            case RE_OPEN_ACC -&gt; {
<b class="fc">&nbsp;                unCloseAccount(foundAccount);</b>
<b class="fc">&nbsp;                return OutputDto.builder().defaultMessage(String.format(&quot;Account with id %s has been reopened &quot;, accountNumber)).build();</b>
&nbsp;            }
&nbsp;            case BLOCK_ACC -&gt; {
&nbsp;                //Note: account once blocked , no operations can be performed on it not even get
&nbsp;                //only authority reserves the right to unblock it
<b class="fc">&nbsp;                blockAccount(foundAccount);</b>
<b class="fc">&nbsp;                return OutputDto.builder().defaultMessage(String.format(&quot;Account with id %s has been blocked&quot;, accountNumber)).build();</b>
&nbsp;            }
&nbsp;            case INC_APPROVED_LOAN_LIMIT -&gt; {
&nbsp;                //to be done.....
&nbsp;
<b class="nc">&nbsp;                return OutputDto.builder().defaultMessage(&quot;BAAD MAIN KARNGE BSDK&quot;).build();</b>
&nbsp;            }
&nbsp;            case UPDATE_CUSTOMER_DETAILS -&gt; {
<b class="fc">&nbsp;                String location = String.format(&quot;Inside UPDATE_CUSTOMER_DETAILS in %s&quot;, methodName);</b>
<b class="fc">&nbsp;                if (Objects.isNull(foundCustomer)) throw new CustomerException(CustomerException.class,</b>
&nbsp;                        &quot;Please specify a customer id to update details&quot;, location);
<b class="fc">&nbsp;                CustomerDto updatedCustomerDto = mapToCustomerDto(updateCustomerDetails(foundCustomer, customerDto));</b>
<b class="fc">&nbsp;                PageableResponseDto&lt;AccountsDto&gt; pageableResponseDto=accountsPagination(sortDir,sortBy,pageNumber,pageSize,customerId);</b>
&nbsp;
&nbsp;
<b class="fc">&nbsp;                return OutputDto.builder()</b>
<b class="fc">&nbsp;                        .customer(mapToCustomerOutputDto(updatedCustomerDto))</b>
<b class="fc">&nbsp;                        .accountsListPages(pageableResponseDto)</b>
<b class="fc">&nbsp;                        .defaultMessage(String.format(&quot;Customer with id %s has been updated&quot;,customerId)).build();</b>
&nbsp;            }
<b class="fc">&nbsp;            default -&gt; throw new AccountsException(AccountsException.class,</b>
<b class="fc">&nbsp;                    String.format(&quot;Invalid request type %s for PUT request&quot;, request), methodName);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public OutputDto deleteRequestExecutor(DeleteInputRequestDto deleteInputRequestDto) throws AccountsException {
<b class="fc">&nbsp;        String methodName = &quot;requestExecutor(InputDto) in AccountsServiceImpl&quot;;</b>
&nbsp;        //map
<b class="fc">&nbsp;        AccountsDto accountsDto = deleteRequestInputToAccountsDto(deleteInputRequestDto);</b>
<b class="fc">&nbsp;        CustomerDto customerDto = deleteInputRequestToCustomerDto(deleteInputRequestDto);</b>
&nbsp;        //check the request type
<b class="fc">&nbsp;        if (null == accountsDto.getUpdateRequest())</b>
<b class="nc">&nbsp;            throw new AccountsException(AccountsException.class, &quot;update request field must not be blank&quot;, methodName);</b>
<b class="fc">&nbsp;        AccountsDto.UpdateRequest request = accountsDto.getUpdateRequest();</b>
<b class="fc">&nbsp;        switch (request) {</b>
&nbsp;            case DELETE_ACC -&gt; {
<b class="fc">&nbsp;                Long accountNumber = accountsDto.getAccountNumber();</b>
<b class="fc">&nbsp;                deleteAccount(accountNumber);</b>
<b class="fc">&nbsp;                return OutputDto.builder().defaultMessage(String.format(&quot;Account with id %s is successfully deleted&quot;, accountNumber)).build();</b>
&nbsp;            }
&nbsp;            case DELETE_ALL_ACC -&gt; {
<b class="fc">&nbsp;                deleteAllAccountsByCustomer(customerDto.getCustomerId());</b>
<b class="fc">&nbsp;                return OutputDto.builder()</b>
<b class="fc">&nbsp;                        .defaultMessage(String.format(&quot;All accounts that belonged to customer with id %s has been deleted&quot;,</b>
<b class="fc">&nbsp;                                customerDto.getCustomerId())).build();</b>
&nbsp;            }
<b class="fc">&nbsp;            default -&gt; throw new AccountsException(AccountsException.class,</b>
<b class="fc">&nbsp;                    String.format(&quot;Invalid request type %s for DELETE request&quot;, request), methodName);</b>
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-06-18 13:59</div>
</div>
</body>
</html>
